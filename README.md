# [이정환님] 한 입 크기로 잘라 먹는 리액트(React.js) : 기초부터 실전까지

## 배운점

## 1. Vite (빌드 도구)

### Vite의 특징
- 빠른 개발 서버 시작과 핫 모듈 교체(HMR) 제공
- ES 모듈을 기반으로 한 개발 서버
- 프로덕션 빌드를 위한 Rollup 기반 번들링
- TypeScript, JSX, CSS 등 다양한 기능 내장 지원

### Vite의 장점
- 개발 서버 시작이 매우 빠름 (webpack 대비)
- 번들링 없이 ES 모듈을 직접 사용하여 빠른 HMR
- 설정이 간단하고 직관적
- 최신 웹 기술 지원 (ESM, TypeScript 등)
- 프로덕션 빌드 시 자동 코드 분할

### Vite 설정
- vite.config.js 파일을 통해 설정 가능
- 플러그인 시스템을 통한 기능 확장
- 환경 변수 관리 (.env 파일)
- 프록시 설정, 빌드 최적화 등 다양한 옵션 제공

## 2. 클라이언트 사이드 렌더링 (CSR)

### CSR의 개념
- 브라우저에서 JavaScript를 사용하여 페이지를 렌더링하는 방식
- 초기 HTML은 비어있거나 최소한의 내용만 포함
- JavaScript가 로드된 후 DOM을 동적으로 생성
- React, Vue, Angular 등의 프레임워크가 주로 사용

### CSR의 장점
- 서버 부하 감소 (렌더링 작업이 클라이언트로 이전)
- 풍부한 사용자 경험 제공 (동적 UI 업데이트)
- 서버와의 통신 최소화 (필요한 데이터만 요청)
- 오프라인 기능 구현 용이 (PWA)
- 개발 생산성 향상 (컴포넌트 기반 개발)

### React의 CSR 구현 방식
- ReactDOM.render() 또는 createRoot()를 통해 앱을 마운트
- 가상 DOM(Virtual DOM)을 사용하여 효율적인 DOM 업데이트
- 컴포넌트 기반 아키텍처로 UI를 구성
- 상태 변경 시 컴포넌트 리렌더링 및 가상 DOM 비교
- React Fiber 아키텍처를 통한 렌더링 최적화
- 이벤트 위임(Event Delegation)을 통한 이벤트 처리 최적화
- React의 생명주기 메서드와 Hooks를 통한 렌더링 제어
- React Router를 통한 클라이언트 사이드 라우팅 구현

## 3. 단일 페이지 애플리케이션 (SPA)

### SPA의 개념
- 하나의 HTML 페이지에서 JavaScript를 사용하여 동적으로 콘텐츠를 변경
- 페이지 전환 시 서버에 요청하지 않고 클라이언트에서 렌더링
- React, Vue, Angular 등의 프레임워크로 구현
- 클라이언트 사이드 라우팅 사용

### SPA의 장점
- 페이지 전환 시 깜빡임 없이 부드러운 사용자 경험
- 서버 부하 감소 (필요한 데이터만 요청)
- 오프라인 지원 가능 (PWA 구현)
- 개발 생산성 향상 (컴포넌트 기반 개발)

### SPA의 단점
- 초기 로딩 시간이 길 수 있음 (JavaScript 번들 크기)
- SEO에 불리할 수 있음 (검색 엔진이 JavaScript를 실행하지 않는 경우)
- 브라우저 히스토리 관리 필요
- 메모리 사용량 증가 가능성

### SPA 최적화 전략
- 코드 분할(Code Splitting)을 통한 초기 로딩 시간 단축
- 라우트 기반 청크 분할
- 지연 로딩(Lazy Loading) 구현
- 서비스 워커를 활용한 캐싱
- 번들 크기 최적화 (트리 쉐이킹, 미니파이)

## 4. 컴포넌트 생명주기 (Lifecycle)

### 마운트 (Mount)
- 컴포넌트가 처음 생성되어 DOM에 삽입될 때
- 컴포넌트가 처음 마운트될 때 한 번만 실행됨
- useEffect의 첫 번째 렌더링 시점
- 초기 데이터 fetching, 이벤트 리스너 등록 등에 활용

### 업데이트 (Update)
- 컴포넌트가 리렌더링될 때
- 상태나 props가 변경될 때마다 실행됨
- 부모 컴포넌트의 리렌더링으로 인한 자식 컴포넌트 업데이트
- useEffect의 의존성 배열에 있는 값이 변경될 때

### 언마운트 (Unmount)
- 컴포넌트가 DOM에서 제거될 때
- 클린업(cleanup) 함수가 실행되는 시점
- 메모리 누수 방지를 위한 이벤트 리스너 제거
- 구독 해제, 타이머 정리 등에 활용

## 5. 리렌더링 조건

컴포넌트가 리렌더링되는 경우:
1. 자신이 관리하는 state가 변경되었을 때
2. 자신이 관리하는 props가 변경되었을 때
3. 부모 컴포넌트가 리렌더링되면 자식도 리렌더링됨
4. Context 값이 변경되었을 때 (해당 Context를 구독하는 컴포넌트)

> 💡 Tip: 컴포넌트들의 state들을 모두 부모에 넣는 것이 아니라 분리하는 것이 좋음
> - 상태 관리의 책임을 적절히 분배하여 컴포넌트의 재사용성과 유지보수성 향상
> - 불필요한 리렌더링 방지
> - 컴포넌트 간의 결합도 감소

## 6. Hook 사용 규칙

1. 함수 컴포넌트, 커스텀 훅 내부에서만 호출 가능
   - 클래스 컴포넌트에서는 사용 불가
   - 일반 JavaScript 함수에서는 사용 불가
2. 조건부로 호출될 수 없음
   - if문, for문, while문 등 내부에서 사용 불가
   - 항상 컴포넌트의 최상위 레벨에서 호출해야 함
3. 나만의 훅(Custom Hook)을 직접 만들 수 있음
   - 'use'로 시작하는 이름 규칙 준수
   - 로직 재사용성 향상
   - 관심사 분리를 통한 코드 구조화

## 7. JSX 주의사항

1. 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있음
   - 조건문, 반복문 등은 삼항 연산자나 map() 함수로 대체
   - 함수 호출, 변수 참조 가능
2. 숫자, 문자열, 배열 값만 렌더링됨
   - 객체는 직접 렌더링 불가
   - null, undefined, boolean은 렌더링되지 않음
3. 모든 태그는 닫혀있어야 함
   - self-closing 태그 사용 가능 (예: <img />)
4. 최상위 태그는 반드시 하나여야 함 (빈 태그도 가능)
   - Fragment(<>) 사용 가능
   - 불필요한 DOM 노드 생성 방지

## 8. 성능 최적화

### useMemo
- 마운트될 때만 생성되고 다시는 생성되지 않아 최적화됨
- 컴포넌트가 리렌더링되면 객체도 다시 생성되기 때문에, value props로 그냥 전달하면 객체가 계속해서 다시 생성됨
- useMemo를 사용하여 한 번만 생성하도록 할 수 있음
- 복잡한 계산 결과를 메모이제이션
- 의존성 배열의 값이 변경될 때만 재계산

### useCallback
- 함수를 메모이제이션하여 불필요한 재생성 방지
- 자식 컴포넌트에 함수를 props로 전달할 때 유용
- 의존성 배열의 값이 변경될 때만 함수 재생성
- React.memo와 함께 사용하면 최적의 성능 최적화 가능
- 이벤트 핸들러 함수를 메모이제이션할 때 주로 사용

### memo
- 객체 타입의 props를 전달받는 컴포넌트는 memo만으로는 최적화가 어려움
- memo의 두 번째 콜백함수에서 props를 수동으로 검증해야 함
- True를 반환하면 리렌더링하지 않음
- 얕은 비교(shallow compare)만 수행
- 복잡한 객체 비교가 필요한 경우 두 번째 콜백함수 활용

### memo와 부모-자식 컴포넌트 관계
- 부모 컴포넌트가 리렌더링될 때 자식 컴포넌트도 기본적으로 리렌더링됨
- memo로 감싼 자식 컴포넌트는 props가 변경되지 않으면 리렌더링되지 않음
- 부모에서 전달하는 props가 객체나 함수인 경우 useMemo, useCallback과 함께 사용해야 효과적
- 부모 컴포넌트의 상태 변경이 자식 컴포넌트에 영향을 주지 않아야 할 때 memo 사용
- 불필요한 리렌더링을 방지하여 성능 최적화 가능

### memo 사용 시 주의사항
- 모든 컴포넌트를 memo로 감싸는 것은 오히려 성능 저하를 일으킬 수 있음
- 간단한 컴포넌트나 자주 변경되는 컴포넌트는 memo 사용을 피하는 것이 좋음
- props 비교 비용이 리렌더링 비용보다 클 수 있으므로 신중하게 사용
- 컴포넌트 트리가 깊을수록 memo의 효과가 더 커짐
- 개발 모드에서는 React DevTools를 통해 memo의 효과를 확인 가능

## 9. Context API

### createContext
- 컴포넌트 트리를 통해 데이터를 전달하는 방법
- props drilling 문제 해결
- 전역 상태 관리에 활용
- Provider와 Consumer 패턴 사용

### Context 사용 시 주의사항
- Context 값이 변경되면 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됨
- 자주 변경되는 값은 Context로 관리하지 않는 것이 좋음
- Context를 여러 개로 분리하여 사용하면 불필요한 리렌더링 방지 가능
- Context.Provider의 value prop은 항상 새로운 객체를 생성하지 않도록 주의

## 10. useReducer와 dispatch

### useReducer
- useState의 대안으로 복잡한 상태 로직을 관리하는 Hook
- 상태 업데이트 로직을 컴포넌트 외부로 분리 가능
- reducer 함수를 통해 상태 변경 로직을 중앙화
- 초기 상태와 reducer 함수를 인자로 받음

### dispatch
- 상태 변화가 있어야 한다는 사실을 알리는, 발송하는 함수
- 액션 객체를 인수로 받음 (상태가 어떻게 변화되길 원하는지 정의)
- reducer 함수를 통해 상태 변경을 처리
- 컴포넌트 내에서 상태 변경을 요청하는 방법

### useReducer 사용 시기
- 복잡한 상태 로직이 있는 경우
- 여러 상태가 서로 연관되어 있는 경우
- 상태 업데이트 로직이 반복되는 경우
- 상태 변경 로직을 재사용하고 싶은 경우

### useReducer 장점
- 상태 업데이트 로직을 컴포넌트와 분리하여 가독성 향상
- 상태 변경 로직을 중앙화하여 유지보수성 향상
- 상태 변경 로직을 재사용 가능
- 디버깅이 용이함 (액션 객체를 통해 상태 변경 추적 가능)

## 11. useEffect 최적화

- 의존성 배열을 사용하여 특정 값이 변경될 때만 실행되도록 제어
- 배열에 포함된 값이 수정되었을 때만 수행됨
- 불필요한 실행을 방지하여 성능 최적화
- 클린업 함수를 통해 메모리 누수 방지
- 비동기 작업 처리 시 주의 필요 (async/await 직접 사용 불가)